// Cortex SC2 Roleplaying Engine
// Copyright (C) 2009-2010 <http://www.cortexrp.com/>
//
// $Id: InfoCommand.galaxy 2 2010-04-25 01:35:09Z TheBlackMage $
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; version 2 of the License.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

bool libcrtx_command_kill(bool testConds, bool runActions) {
	unitgroup g = libcrtx_utility_getselectedunits();
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitKill( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_remove(bool testConds, bool runActions) {
	unitgroup g = libcrtx_utility_getselectedunits();
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitRemove( UnitGroupLoopCurrent() );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_scale(bool testConds, bool runActions) {
	fixed scale;
	unitgroup g = libcrtx_utility_getselectedunits();
	scale = StringToFixed(StringWord(EventChatMessage(false), 2));
	// Verify bounds.
	scale = libcrtx_minFixed( libcrtx_setting_getfixed(libcrtx_setting_fixed_maxscale), scale );
	scale = libcrtx_maxFixed( libcrtx_setting_getfixed(libcrtx_setting_fixed_minscale), scale );

	// Translate to Blizzard SC2 system.
	scale = scale * 100;
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetScale( UnitGroupLoopCurrent(), scale, scale, scale );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;	
}

bool libcrtx_command_give(bool testConds, bool runActions) {
	int newOwner;
	string nextParam;
	unitgroup g = libcrtx_utility_getselectedunits();
	nextParam = StringWord( EventChatMessage(false), 2 );
	newOwner = libcrtx_utility_getplayerfromcolor(nextParam);
	if(newOwner == -1) { // invalid entry by user
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetOwner( UnitGroupLoopCurrent(), newOwner, true );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_givecolor(bool testConds, bool runActions) {
	int newOwner;
	int oldOwner;
	string nextParam;
	unitgroup g = libcrtx_utility_getselectedunits();
	nextParam = StringWord( EventChatMessage(false), 2 );
	newOwner = libcrtx_utility_getplayerfromcolor(nextParam);
	if(newOwner == -1) { // invalid entry by user
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetOwner( UnitGroupLoopCurrent(), newOwner, false );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_color(bool testConds, bool runActions) {
	int newColour;
	string nextParam;
	unitgroup g = libcrtx_utility_getselectedunits();
	nextParam = StringWord( EventChatMessage(false), 2 );
	newColour = libcrtx_utility_getplayerfromdefaultcolor(nextParam);
	if(newColour == -1) { // invalid entry by user
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetTeamColorIndex( UnitGroupLoopCurrent(), newColour );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_invulnerable(bool testConds, bool runActions) {
	unitgroup g = libcrtx_utility_getselectedunits();
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetState( UnitGroupLoopCurrent(), c_unitStateInvulnerable, true );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}


bool libcrtx_command_vulnerable(bool testConds, bool runActions) {
	unitgroup g = libcrtx_utility_getselectedunits();
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetState( UnitGroupLoopCurrent(), c_unitStateInvulnerable, false );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_pause(bool testConds, bool runActions) {
	unitgroup g = libcrtx_utility_getselectedunits();
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetState( UnitGroupLoopCurrent(), c_unitStatePaused, true );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_unpause(bool testConds, bool runActions) {
	unitgroup g = libcrtx_utility_getselectedunits();
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetState( UnitGroupLoopCurrent(), c_unitStatePaused, false );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}


bool libcrtx_command_movable(bool testConds, bool runActions) {
	string msg;
	bool enable;
	bool query;
	string nextParam;
	unitgroup g = libcrtx_utility_getselectedunits();
	query = false;
	nextParam = StringWord( EventChatMessage(false), 2 );
	if( nextParam == "on" ) {
		enable = true;
	} else if( nextParam == "off" ) {
		enable = false; 
	} else {
		// print whether it is or isn't.
		query = true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		if( query ) {
			if( UnitTestState( UnitGroupLoopCurrent(), c_unitStateMoveSuppressed ) ) {
				libcrtx_write( PlayerGroupSingle(EventPlayer()), "This unit is not movable.");
			} else {
				libcrtx_write( PlayerGroupSingle(EventPlayer()), "This unit is movable.");
			}
		} else {
			UnitSetState( UnitGroupLoopCurrent(), c_unitStateMoveSuppressed, enable );
		}

		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_life(bool testConds, bool runActions) {
	string nextParam;
	fixed val;
	bool percent = false;
	int position = 0;
	unitgroup g = libcrtx_utility_getselectedunits();
	nextParam = StringWord( EventChatMessage(false), 2 );

	if( StringContains(nextParam, "%", c_stringAnywhere, c_stringCase) ) {
		percent = true;
		nextParam = StringSub(nextParam, 1, StringLength(nextParam)-1);
	}

	val = StringToFixed(nextParam);

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		if(percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifePercent, val );
		} else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLife, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_energy(bool testConds, bool runActions) {
	string nextParam;
	fixed val;
	bool percent = false;
	int position = 0;
	unitgroup g = libcrtx_utility_getselectedunits();
	nextParam = StringWord( EventChatMessage(false), 2 );

	if( StringContains(nextParam, "%", c_stringAnywhere, c_stringCase) ) {
		percent = true;
		nextParam = StringSub(nextParam, 1, StringLength(nextParam)-1);
	}

	val = StringToFixed(nextParam);

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		if(percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyPercent, val );
		} else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergy, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_shields(bool testConds, bool runActions) {
	string nextParam;
	fixed val;
	bool percent = false;
	int position = 0;
	unitgroup g = libcrtx_utility_getselectedunits();
	nextParam = StringWord( EventChatMessage(false), 2 );

	if( StringContains(nextParam, "%", c_stringAnywhere, c_stringCase) ) {
		percent = true;
		nextParam = StringSub(nextParam, 1, StringLength(nextParam)-1);
	}

	val = StringToFixed(nextParam);

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		if(percent) {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsPercent, val );
		} else {
			UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShields, val );
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_tint(bool testConds, bool runActions) {
	string paramOne;
	string paramTwo;
	string paramThree;
	string paramFour;

	int red;
	int green;
	int blue;
	fixed alpha;

	string amsg;
	actorscope ascope;
	actor act;

	unitgroup g = libcrtx_utility_getselectedunits();

	paramOne = StringWord( EventChatMessage(false), 2 );
	paramTwo = StringWord( EventChatMessage(false), 3 );
	paramThree = StringWord( EventChatMessage(false), 4 );
	paramFour = StringWord( EventChatMessage(false), 5 );

	red = libcrtx_boundsInt(StringToInt(paramOne), 0, 255);
	green = libcrtx_boundsInt(StringToInt(paramTwo), 0, 255);
	blue = libcrtx_boundsInt(StringToInt(paramThree), 0, 255);
	alpha = libcrtx_boundsFixed(StringToFixed(paramFour), 0.0, 1.0);

	if( paramFour == "" ) { // Unspecified, default to 1.0
		alpha = 1.0;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		ActorSend(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), "SetTintColor " + IntToString(red) + "," + IntToString(green) + "," + IntToString(blue));
		ActorSend(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), "SetOpacity " + FixedToString(alpha, c_fixedPrecisionAny) + "," + "0");
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_face(bool testConds, bool runActions) {
	fixed angleToFace;
	string nextParam;
	unitgroup g = libcrtx_utility_getselectedunits();

	nextParam = StringWord( EventChatMessage(false), 2 );
	if( nextParam != "" ) {
		angleToFace = StringToFixed( nextParam );
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		// face spawner
		if( nextParam == "" ) {
			libNtve_gf_MakeUnitFacePoint( UnitGroupLoopCurrent(), UnitGetPosition(libcrtx_utility_getspawner()), 0.0 );
		} else {
			// face angle
			UnitSetFacing( UnitGroupLoopCurrent(), angleToFace, 0.0 );
			libcrtx_debug("making face " + FixedToString(angleToFace, c_fixedPrecisionAny));
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_height(bool testConds, bool runActions) {
	fixed height;
	fixed time;
	string nextParam;
	unitgroup g = libcrtx_utility_getselectedunits();
	nextParam = StringWord( EventChatMessage(false), 2 );
	height = StringToFixed( nextParam );
	nextParam = StringWord( EventChatMessage(false), 3 );
	time = StringToFixed( nextParam );

	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() )
	{
		// set height
		UnitSetHeight( UnitGroupLoopCurrent(), height, time );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_addweapon(bool testConds, bool runActions) {
	string weapon;
	string turret;
	unitgroup g = libcrtx_utility_getselectedunits();
	weapon = StringWord( EventChatMessage(false), 2 );
	turret = StringWord( EventChatMessage(false), 3 );
	
	if( turret == "" ) {
		turret = "CTurret";
	}
	
	// use toolkit on weapon
	weapon = libcrtx_toolkit_getweapon(weapon);

	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() )
	{
		UnitWeaponAdd( UnitGroupLoopCurrent(), weapon, turret );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_removeweapon(bool testConds, bool runActions) {
	string weapon;
	unitgroup g = libcrtx_utility_getselectedunits();
	weapon = StringWord( EventChatMessage(false), 2 );

	// use toolkit on weapon
	weapon = libcrtx_toolkit_getweapon(weapon);
	
	UnitGroupLoopBegin(g);
	while( !UnitGroupLoopDone() )
	{
		UnitWeaponRemove( UnitGroupLoopCurrent(), weapon );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_maxlife(bool testConds, bool runActions) {
	fixed val;
	unitgroup g = libcrtx_utility_getselectedunits();
	val = StringToFixed(StringWord( EventChatMessage(false), 2 ));

	if( val <= 0 ) { // Bad input!
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropLifeMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_maxenergy(bool testConds, bool runActions) {
	fixed val;
	unitgroup g = libcrtx_utility_getselectedunits();
	val = StringToFixed(StringWord( EventChatMessage(false), 2 ));

	if( val <= 0 ) { // Bad input!
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropEnergyMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_maxshields(bool testConds, bool runActions) {
	fixed val;
	unitgroup g = libcrtx_utility_getselectedunits();
	val = StringToFixed(StringWord( EventChatMessage(false), 2 ));

	if( val <= 0 ) { // Bad input!
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropShieldsMax, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_speed(bool testConds, bool runActions) {
	fixed val;
	unitgroup g = libcrtx_utility_getselectedunits();
	val = StringToFixed(StringWord( EventChatMessage(false), 2 ));

	if( val <= 0 ) { // Bad input!
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropMovementSpeed, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}

bool libcrtx_command_kills(bool testConds, bool runActions) {
	fixed val;
	unitgroup g = libcrtx_utility_getselectedunits();
	val = StringToFixed(StringWord( EventChatMessage(false), 2 ));

	if( val <= 0 ) { // Bad input!
		return true;
	}

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone())
	{
		UnitSetPropertyFixed( UnitGroupLoopCurrent(), c_unitPropKills, val );
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	return true;
}